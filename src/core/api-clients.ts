//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IClient {

    /**
     * Create User
     * @return Successful Response
     */
    auth_create_user_post(body: AdminUserCreate): Promise<TokenResponse>;

    /**
     * Admin Login
     * @return Successful Response
     */
    auth_admin_login_post(body: AdminLogin): Promise<TokenResponse>;

    /**
     * Agent Login
     * @return Successful Response
     */
    auth_agent_login_post(body: AgentLogin): Promise<TokenResponse>;

    /**
     * Email Login
     * @return Successful Response
     */
    auth_email_login_post(body: UserLogin): Promise<TokenResponse>;

    /**
     * Generate Password
     * @return Successful Response
     */

    auth_generate_password_post(body: GeneratePassword): Promise<GeneratePasswordResponse>;

    /**
     * Create Admin
     * @return Successful Response
     */
    admin_create_admin_post(body: AdminUserCreate): Promise<AdminUserCreateResponse>;

    /**
     * Create Agent
     * @return Successful Response
     */
    admin_create_agent_post(body: AdminUserCreate): Promise<AgentCreateResponse>;

    /**
     * Update Agent
     * @return Successful Response
     */
    admin_update_agent_post(body: AgentUpdate): Promise<AgentUpdateResponse>;

    /**
     * Remove Agent
     * @return Successful Response
     */
    admin_remove_agent_post(body: App__api__admin__schema__RemoveUser): Promise<BaseResponse>;

    /**
     * List Agents
     * @return Successful Response
     */
    admin_list_agents_post(body: GetUserList): Promise<ListAdminUserResponse>;

    /**
     * Get Agent
     * @return Successful Response
     */
    admin_get_agent_post(body: App__api__admin__schema__GetAgent): Promise<BaseResponse>;

    /**
     * Search Users
     * @return Successful Response
     */
    admin_search_users_post(body: SearchUser): Promise<SearchResults>;

    /**
     * Create User
     * @return Successful Response
     */
    agent_create_user_post(body: AgentCreateUser): Promise<AgentCreateUserResponse>;

    /**
     * Update User
     * @return Successful Response
     */
    agent_update_user_post(body: UpdateUser): Promise<UpdateUserResponse>;

    /**
     * Remove User
     * @return Successful Response
     */
    agent_remove_user_post(body: App__api__agent__schema__RemoveUser): Promise<BaseResponse>;

    /**
     * List Agents
     * @return Successful Response
     */
    agent_list_agents_post(body: GetAgentList): Promise<PagedBaseResponse>;

    /**
     * Get Agent
     * @return Successful Response
     */
    agent_get_agent_post(body: App__api__agent__schema__GetAgent): Promise<GetAgentResponse>;

    /**
     * Get Agent Users
     * @return Successful Response
     */
    agent_get_agent_users_post(body: GetAgentUsers): Promise<GetAgentUsersResponse>;

    /**
     * Get User Data
     * @return Successful Response
     */
    user_get_user_data_get(): Promise<LoadUserResponse>;

    /**
     * Post User Data
     * @return Successful Response
     */
    user_post_user_data_post(body: GetUser): Promise<LoadUserResponse>;

    /**
     * List All Users
     * @return Successful Response
     */
    user_list_all_users_post(body: GetAllUsers): Promise<GetUserListResponse>;

    /**
     * Create Credit
     * @return Successful Response
     */
    credit_create_credit_post(body: CreateUserCredit): Promise<CreateUserCreditResponse>;

    /**
     * Get Credit
     * @return Successful Response
     */
    credit_get_credit_post(body: GetUserCredit): Promise<GetUserCreditResponse>;

    /**
     * Update Credit
     * @return Successful Response
     */
    credit_update_credit_post(body: UpdateUserCredit): Promise<UpdateUserCreditResponse>;

    /**
     * Create Game
     * @return Successful Response
     */
    game_create_game_post(body: CreateGame): Promise<CreateGameResponse>;

    /**
     * Get Game
     * @return Successful Response
     */
    game_get_game_post(body: GetGame): Promise<GetGameResponse>;

    /**
     * Update Game
     * @return Successful Response
     */
    game_update_game_post(body: UpdateGame): Promise<UpdateGameResponse>;

    /**
     * Get All Games
     * @return Successful Response
     */
    game_get_all_games_post(body: ListAllGames): Promise<PagedListAllGamesResponse>;

    /**
     * Get Bet History
     * @return Successful Response
     */
    history_get_bet_history__post(body: GetBetHistory): Promise<GetBetHistoryResponse>;

    /**
     * Get Action History
     * @return Successful Response
     */
    history_get_action_history__post(body: GetActionHistory): Promise<GetActionHistoryResponse>;

    /**
     * Get Payment History
     * @return Successful Response
     */
    history_get_payment_history__post(body: GetPaymentHistory): Promise<GetPaymentHistoryResponse>;
}

export class Client implements IClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Create User
     * @return Successful Response
     */
    auth_create_user_post(body: AdminUserCreate): Promise<TokenResponse> {
        let url_ = this.baseUrl + "/api/auth/signup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuth_create_user_post(_response);
        });
    }

    protected processAuth_create_user_post(response: Response): Promise<TokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenResponse>(null as any);
    }

    /**
     * Generate Password for User
     * @return Successful Response
     */

    auth_generate_password_post(body: GeneratePassword): Promise<GeneratePasswordResponse> {
        let url_ = this.baseUrl + "/api/auth/generate_password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuth_generate_password_post(_response);
        });
    }

    protected processAuth_generate_password_post(response: Response): Promise<GeneratePasswordResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GeneratePasswordResponse>(null as any);
    }

    /**
     * Admin Login
     * @return Successful Response
     */
    auth_admin_login_post(body: AdminLogin): Promise<TokenResponse> {
        let url_ = this.baseUrl + "/api/auth/login/admin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuth_admin_login_post(_response);
        });
    }

    protected processAuth_admin_login_post(response: Response): Promise<TokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenResponse>(null as any);
    }

    /**
     * Agent Login
     * @return Successful Response
     */
    auth_agent_login_post(body: AgentLogin): Promise<TokenResponse> {
        let url_ = this.baseUrl + "/api/auth/login/agent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuth_agent_login_post(_response);
        });
    }

    protected processAuth_agent_login_post(response: Response): Promise<TokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenResponse>(null as any);
    }

    /**
     * Email Login
     * @return Successful Response
     */
    auth_email_login_post(body: UserLogin): Promise<TokenResponse> {
        let url_ = this.baseUrl + "/api/auth/login/email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuth_email_login_post(_response);
        });
    }

    protected processAuth_email_login_post(response: Response): Promise<TokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenResponse>(null as any);
    }

    /**
     * Create Admin
     * @return Successful Response
     */
    admin_create_admin_post(body: AdminUserCreate): Promise<AdminUserCreateResponse> {
        let url_ = this.baseUrl + "/api/admin/manage/create_admin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdmin_create_admin_post(_response);
        });
    }

    protected processAdmin_create_admin_post(response: Response): Promise<AdminUserCreateResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminUserCreateResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AdminUserCreateResponse>(null as any);
    }

    /**
     * Create Agent
     * @return Successful Response
     */
    admin_create_agent_post(body: AdminUserCreate): Promise<AgentCreateResponse> {
        let url_ = this.baseUrl + "/api/admin/manage/create_agent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdmin_create_agent_post(_response);
        });
    }

    protected processAdmin_create_agent_post(response: Response): Promise<AgentCreateResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AgentCreateResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AgentCreateResponse>(null as any);
    }

    /**
     * Update Agent
     * @return Successful Response
     */
    admin_update_agent_post(body: AgentUpdate): Promise<AgentUpdateResponse> {
        let url_ = this.baseUrl + "/api/admin/manage/update_agent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdmin_update_agent_post(_response);
        });
    }

    protected processAdmin_update_agent_post(response: Response): Promise<AgentUpdateResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AgentUpdateResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AgentUpdateResponse>(null as any);
    }

    /**
     * Remove Agent
     * @return Successful Response
     */
    admin_remove_agent_post(body: App__api__admin__schema__RemoveUser): Promise<BaseResponse> {
        let url_ = this.baseUrl + "/api/admin/manage/remove_agent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdmin_remove_agent_post(_response);
        });
    }

    protected processAdmin_remove_agent_post(response: Response): Promise<BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BaseResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseResponse>(null as any);
    }

    /**
     * List Agents
     * @return Successful Response
     */
    admin_list_agents_post(body: GetUserList): Promise<ListAdminUserResponse> {
        let url_ = this.baseUrl + "/api/admin/list_agents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdmin_list_agents_post(_response);
        });
    }

    protected processAdmin_list_agents_post(response: Response): Promise<ListAdminUserResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ListAdminUserResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListAdminUserResponse>(null as any);
    }

    /**
     * Get Agent
     * @return Successful Response
     */
    admin_get_agent_post(body: App__api__admin__schema__GetAgent): Promise<BaseResponse> {
        let url_ = this.baseUrl + "/api/admin/get_agent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdmin_get_agent_post(_response);
        });
    }

    protected processAdmin_get_agent_post(response: Response): Promise<BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BaseResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseResponse>(null as any);
    }

    /**
     * Search Users
     * @return Successful Response
     */
    admin_search_users_post(body: SearchUser): Promise<SearchResults> {
        let url_ = this.baseUrl + "/api/admin/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdmin_search_users_post(_response);
        });
    }

    protected processAdmin_search_users_post(response: Response): Promise<SearchResults> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SearchResults;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchResults>(null as any);
    }

    /**
     * Create User
     * @return Successful Response
     */
    agent_create_user_post(body: AgentCreateUser): Promise<AgentCreateUserResponse> {
        let url_ = this.baseUrl + "/api/agent/manage/create_user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgent_create_user_post(_response);
        });
    }

    protected processAgent_create_user_post(response: Response): Promise<AgentCreateUserResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AgentCreateUserResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AgentCreateUserResponse>(null as any);
    }

    /**
     * Update User
     * @return Successful Response
     */
    agent_update_user_post(body: UpdateUser): Promise<UpdateUserResponse> {
        let url_ = this.baseUrl + "/api/agent/manage/update_user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgent_update_user_post(_response);
        });
    }

    protected processAgent_update_user_post(response: Response): Promise<UpdateUserResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UpdateUserResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UpdateUserResponse>(null as any);
    }

    /**
     * Remove User
     * @return Successful Response
     */
    agent_remove_user_post(body: App__api__agent__schema__RemoveUser): Promise<BaseResponse> {
        let url_ = this.baseUrl + "/api/agent/manage/remove_user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgent_remove_user_post(_response);
        });
    }

    protected processAgent_remove_user_post(response: Response): Promise<BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BaseResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseResponse>(null as any);
    }

    /**
     * List Agents
     * @return Successful Response
     */
    agent_list_agents_post(body: GetAgentList): Promise<PagedBaseResponse> {
        let url_ = this.baseUrl + "/api/agent/list_agents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgent_list_agents_post(_response);
        });
    }

    protected processAgent_list_agents_post(response: Response): Promise<PagedBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PagedBaseResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedBaseResponse>(null as any);
    }

    /**
     * Get Agent
     * @return Successful Response
     */
    agent_get_agent_post(body: App__api__agent__schema__GetAgent): Promise<GetAgentResponse> {
        let url_ = this.baseUrl + "/api/agent/get_agent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgent_get_agent_post(_response);
        });
    }

    protected processAgent_get_agent_post(response: Response): Promise<GetAgentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetAgentResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetAgentResponse>(null as any);
    }

    /**
     * Get Agent Users
     * @return Successful Response
     */
    agent_get_agent_users_post(body: GetAgentUsers): Promise<GetAgentUsersResponse> {
        let url_ = this.baseUrl + "/api/agent/get_agent_users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgent_get_agent_users_post(_response);
        });
    }

    protected processAgent_get_agent_users_post(response: Response): Promise<GetAgentUsersResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetAgentUsersResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetAgentUsersResponse>(null as any);
    }

    /**
     * Get User Data
     * @return Successful Response
     */
    user_get_user_data_get(): Promise<LoadUserResponse> {
        let url_ = this.baseUrl + "/api/user/get_user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUser_get_user_data_get(_response);
        });
    }

    protected processUser_get_user_data_get(response: Response): Promise<LoadUserResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadUserResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoadUserResponse>(null as any);
    }

    /**
     * Post User Data
     * @return Successful Response
     */
    user_post_user_data_post(body: GetUser): Promise<LoadUserResponse> {
        let url_ = this.baseUrl + "/api/user/get_user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUser_post_user_data_post(_response);
        });
    }

    protected processUser_post_user_data_post(response: Response): Promise<LoadUserResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadUserResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoadUserResponse>(null as any);
    }

    /**
     * List All Users
     * @return Successful Response
     */
    user_list_all_users_post(body: GetAllUsers): Promise<GetUserListResponse> {
        let url_ = this.baseUrl + "/api/user/list_all_users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUser_list_all_users_post(_response);
        });
    }

    protected processUser_list_all_users_post(response: Response): Promise<GetUserListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetUserListResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetUserListResponse>(null as any);
    }

    /**
     * Create Credit
     * @return Successful Response
     */
    credit_create_credit_post(body: CreateUserCredit): Promise<CreateUserCreditResponse> {
        let url_ = this.baseUrl + "/api/credit/manage/create_user_credit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCredit_create_credit_post(_response);
        });
    }

    protected processCredit_create_credit_post(response: Response): Promise<CreateUserCreditResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateUserCreditResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateUserCreditResponse>(null as any);
    }

    /**
     * Get Credit
     * @return Successful Response
     */
    credit_get_credit_post(body: GetUserCredit): Promise<GetUserCreditResponse> {
        let url_ = this.baseUrl + "/api/credit/manage/get_user_credit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCredit_get_credit_post(_response);
        });
    }

    protected processCredit_get_credit_post(response: Response): Promise<GetUserCreditResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetUserCreditResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetUserCreditResponse>(null as any);
    }

    /**
     * Update Credit
     * @return Successful Response
     */
    credit_update_credit_post(body: UpdateUserCredit): Promise<UpdateUserCreditResponse> {
        let url_ = this.baseUrl + "/api/credit/manage/update_user_credit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCredit_update_credit_post(_response);
        });
    }

    protected processCredit_update_credit_post(response: Response): Promise<UpdateUserCreditResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UpdateUserCreditResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UpdateUserCreditResponse>(null as any);
    }

    /**
     * Create Game
     * @return Successful Response
     */
    game_create_game_post(body: CreateGame): Promise<CreateGameResponse> {
        let url_ = this.baseUrl + "/api/Game/manage/create_Game";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGame_create_game_post(_response);
        });
    }

    protected processGame_create_game_post(response: Response): Promise<CreateGameResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateGameResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateGameResponse>(null as any);
    }

    /**
     * Get Game
     * @return Successful Response
     */
    game_get_game_post(body: GetGame): Promise<GetGameResponse> {
        let url_ = this.baseUrl + "/api/Game/manage/get_game";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGame_get_game_post(_response);
        });
    }

    protected processGame_get_game_post(response: Response): Promise<GetGameResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetGameResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetGameResponse>(null as any);
    }

    /**
     * Update Game
     * @return Successful Response
     */
    game_update_game_post(body: UpdateGame): Promise<UpdateGameResponse> {
        let url_ = this.baseUrl + "/api/Game/manage/update_game";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGame_update_game_post(_response);
        });
    }

    protected processGame_update_game_post(response: Response): Promise<UpdateGameResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UpdateGameResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UpdateGameResponse>(null as any);
    }

    /**
     * Get All Games
     * @return Successful Response
     */
    game_get_all_games_post(body: ListAllGames): Promise<PagedListAllGamesResponse> {
        let url_ = this.baseUrl + "/api/Game/manage/get_all_games";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGame_get_all_games_post(_response);
        });
    }

    protected processGame_get_all_games_post(response: Response): Promise<PagedListAllGamesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PagedListAllGamesResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedListAllGamesResponse>(null as any);
    }

    /**
     * Get Bet History
     * @return Successful Response
     */
    history_get_bet_history__post(body: GetBetHistory): Promise<GetBetHistoryResponse> {
        let url_ = this.baseUrl + "/api/history/get_bet_history";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHistory_get_bet_history__post(_response);
        });
    }

    protected processHistory_get_bet_history__post(response: Response): Promise<GetBetHistoryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetBetHistoryResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetBetHistoryResponse>(null as any);
    }

    /**
     * Get Action History
     * @return Successful Response
     */
    history_get_action_history__post(body: GetActionHistory): Promise<GetActionHistoryResponse> {
        let url_ = this.baseUrl + "/api/history/get_action_history";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHistory_get_action_history__post(_response);
        });
    }

    protected processHistory_get_action_history__post(response: Response): Promise<GetActionHistoryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetActionHistoryResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetActionHistoryResponse>(null as any);
    }

    /**
     * Get Payment History
     * @return Successful Response
     */
    history_get_payment_history__post(body: GetPaymentHistory): Promise<GetPaymentHistoryResponse> {
        let url_ = this.baseUrl + "/api/history/get_payment_history";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHistory_get_payment_history__post(_response);
        });
    }

    protected processHistory_get_payment_history__post(response: Response): Promise<GetPaymentHistoryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPaymentHistoryResponse;
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HTTPValidationError;
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetPaymentHistoryResponse>(null as any);
    }
}

/** `ActionHistory` is a class that is used to represent an action history */
export interface ActionHistory {
    id?: string;
    newValueJson?: string;
    ip?: string;
    createdAt?: Date;
    owner: Owner;

    [key: string]: any;
}

export interface Admin {
    id: string;
    email?: string;
    name?: string;

    [key: string]: any;
}

/** The AdminPagedResponse class is a PagedResponse class that is used to return a list of users */
export interface AdminPagedResponse {
    items: App__api__admin__schema__BaseUserResponse[];
    page: number;
    pageSize: number;
    pages: number;
    total: number;

    [key: string]: any;
}

/** `UserCreate` is a class that is used to validate the data that is being passed to the `/user` route. */
export interface AdminUserCreate {
    email: string;
    password?: string;
    name: string;

    [key: string]: any;
}

/** `AdminUserCreateResponse` is a class that is used to validate the data that is being passed to the `/user` route. */
export interface AdminUserCreateResponse {
    success?: boolean;
    error?: string;
    response?: Response;

    [key: string]: any;
}

export interface AgentContext {
    id?: string;

    [key: string]: any;
}

/** Base Response abstraction for standardized returns */
export interface AgentCreateResponse {
    success: boolean;
    error?: string;
    response?: AgentUser;

    [key: string]: any;
}

/** Base Response abstraction for standardized returns */
export interface GeneratePasswordResponse {
    success: boolean;
    error?: string;
    response?: GeneratedPassword;

    [key: string]: any;
}

/** Base Response abstraction for standardized returns */
export interface GeneratedPassword {
    password: string;

    [key: string]: any;
}

/** `CreateUser` is a class that is used to validate the data that is being passed to the `/user` route. */
export interface AgentCreateUser {
    email: string;
    password?: string;
    username?: string;
    headImage?: string; ///updated me
    credit_account?: CreditAccount;

    [key: string]: any;
}

/** `AgentCreateResponse` is a model that is used to return a response from the `/user` route. */
export interface AgentCreateUserResponse {
    success: boolean;
    error?: string;
    response?: App__api__agent__schema__User;

    [key: string]: any;
}

/** This is a class that is used to validate the data that is being passed to the route. */
export interface AdminLogin {
    email: string;
    password: string;

    [key: string]: any;
}

/** This is a class that is used to validate the data that is being passed to the route. */
export interface AgentLogin {
    email: string;
    password: string;

    [key: string]: any;
}

export interface AgentUpdate {
    id: string;
    quota?: number;
    active?: boolean;

    [key: string]: any;
}

/** Base Response abstraction for standardized returns */
export interface AgentUpdateResponse {
    success: boolean;
    error?: string;
    response?: AgentUser;

    [key: string]: any;
}

/** `Agent` is a class that is used to represent an agent. */
export interface AgentUser {
    id?: string;
    username?: string;
    email?: string;
    createdAt?: Date;
    updatedAt?: Date;
    creditAccount?: App__api__user__schema__UserCredit;

    [key: string]: any;
}

/** Base Response abstraction for standardized returns */
export interface BaseResponse {
    success: boolean;
    error?: string;
    response?: Response2;

    [key: string]: any;
}

/** `User` is a class that is used to validate the data that is being passed to the `/user` route. */
export interface BaseUser {
    id?: string;
    email?: string;
    username?: string;
    createdAt?: Date;
    updatedAt?: Date;
    creditAccount?: App__api__user__schema__UserCredit;

    [key: string]: any;
}

/** `BetHistory` is a class that is used to represent a bet history */
export interface BetHistory {
    id?: string;
    beforeScore?: number;
    betScore?: number;
    winScore?: number;
    newScore?: number;
    updateAt?: Date;
    createdAt?: Date;
    game: App__api__history__schema__Game;
    owner: App__api__history__schema__User;

    [key: string]: any;
}

export interface CreateGame {
    username: string;
    description: string;

    [key: string]: any;
}

export interface CreateGameResponse {
    success: boolean;
    response?: App__api__game__schema__Game;
    error?: string;

    [key: string]: any;
}

/** `CreateUserCredit` is a class that is used to represent a request */
export interface CreateUserCredit {
    balance: number;
    ownerId: string;

    [key: string]: any;
}

/** `CreateUserCreditResponse` is a class that is used to represent a response */
export interface CreateUserCreditResponse {
    success: boolean;
    error?: string;
    response?: App__api__credit__schema__UserCredit;

    [key: string]: any;
}

/** `CreditAccount` is a model that is used to credit an account. */
export interface CreditAccount {
    balance?: number;

    [key: string]: any;
}

export interface Filter {
    filter?: { [key: string]: string; };

    [key: string]: any;
}

/** `GetActionHistory` is a class that is used to represent a request */
export interface GetActionHistory {
    agentID?: string;
    adminID?: string;
    userID?: string;

    [key: string]: any;
}

/** `GetActionHistoryResponse` is a class that is used to represent a response */
export interface GetActionHistoryResponse {
    success: boolean;
    error?: string;
    response?: ActionHistory[];

    [key: string]: any;
}

/** GetUserList is a model that is used to get a list of users. that is used in the `/list` endpoint. */
export interface GetAgentList {
    params: Params;

    [key: string]: any;
}

export interface GetAgentPagedContext {
    filter?: AgentContext;

    [key: string]: any;
}

/** `GetAgentResponse` is a class that is used to represent a response */
export interface GetAgentResponse {
    success: boolean;
    error?: string;
    response?: AgentUser;

    [key: string]: any;
}

export interface GetAgentUsers {
    context: GetAgentPagedContext;
    params: Params;

    [key: string]: any;
}

export interface GetAgentUsersItems {
    items: App__api__agent__schema__BaseUserResponse[];
    page: number;
    pageSize: number;
    pages: number;
    total: number;

    [key: string]: any;
}

/** PagedBaseResponse is a response object that contains a list of objects */
export interface GetAgentUsersResponse {
    success: boolean;
    error?: string;
    response: GetAgentUsersItems;

    [key: string]: any;
}

export interface GetAllUsers {
    context?: IGetUserList;
    params: Params;

    [key: string]: any;
}

/** `GetBetHistory` is a class that is used to represent a request */
export interface GetBetHistory {
    ownerId: string;

    [key: string]: any;
}

/** `GetBetHistoryResponse` is a class that is used to represent a response */
export interface GetBetHistoryResponse {
    success: boolean;
    error?: string;
    response?: BetHistory[];

    [key: string]: any;
}

export interface GetGame {
    id: string;

    [key: string]: any;
}

export interface GetGameResponse {
    success: boolean;
    response?: App__api__game__schema__Game;
    error?: string;

    [key: string]: any;
}

export interface GetPaymentHistory {
    ownerId: string;

    [key: string]: any;
}

/** `GetPaymentHistoryResponse` is a class that is used to represent a response */
export interface GetPaymentHistoryResponse {
    success: boolean;
    error?: string;
    response?: PaymentHistory[];

    [key: string]: any;
}

/** `GetUser` is a class that is used to validate the data that is being passed to the `/user/{userId}` route. */
export interface GetUser {
    id: string;

    [key: string]: any;
}

/** `GetUserCredit` is a class that is used to represent a request */
export interface GetUserCredit {
    ownerId: string;

    [key: string]: any;
}

/** `GetUserCreditResponse` is a class that is used to represent a response */
export interface GetUserCreditResponse {
    success: boolean;
    error?: string;
    response?: App__api__credit__schema__UserCredit;

    [key: string]: any;
}

/** GetUserList is a model that is used to get a list of users. that is used in the `/list` endpoint. */
export interface GetUserList {
    context?: Filter;
    params: Params;

    [key: string]: any;
}

export interface GetUserListItems {
    items: BaseUser[];
    page: number;
    pageSize: number;
    pages: number;
    total: number;

    [key: string]: any;
}

/** PagedBaseResponse is a response object that contains a list of objects */
export interface GetUserListResponse {
    success: boolean;
    error?: string;
    response?: GetUserListItems;

    [key: string]: any;
}

export interface HTTPValidationError {
    detail?: ValidationError[];

    [key: string]: any;
}

export interface IGetUserList {
    filter?: GetUser;

    [key: string]: any;
}

/** The ListUserResponse class is a PagedResponse class that is used to return a list of users */
export interface ListAdminUserResponse {
    success: boolean;
    error?: string;
    response: AdminPagedResponse;

    [key: string]: any;
}

export interface ListAllGames {
    context?: Filter;
    params: Params;

    [key: string]: any;
}

/** `LoadUserResponse` is a class that is used to validate the data that is being passed to the `/user` route. */
export interface LoadUserResponse {
    success: boolean;
    error?: string;
    response?: BaseUser;

    [key: string]: any;
}

/** PagedBaseResponse is a response object that contains a list of objects */
export interface PagedBaseResponse {
    success: boolean;
    error?: string;
    response?: PagedResponse;

    [key: string]: any;
}

export interface PagedGameItems {
    items?: App__api__game__schema__Game[];
    page: number;
    pageSize: number;
    pages: number;
    total: number;

    [key: string]: any;
}

/** PagedBaseResponse is a response object that contains a list of objects */
export interface PagedListAllGamesResponse {
    success: boolean;
    error?: string;
    response?: PagedGameItems;

    [key: string]: any;
}

export interface PagedResponse {
    items: any[];
    page: number;
    pageSize: number;
    pages: number;
    total: number;

    [key: string]: any;
}

export interface Params {
    page: number;
    size: number;

    [key: string]: any;
}

/** `PaymentHistory` is a class that is used to represent a payment history */
export interface PaymentHistory {
    beforeScore?: number;
    changeScore?: number;
    newScore?: number;
    approval?: boolean;
    createdAt?: Date;
    approvedAt?: Date;
    owner: App__api__history__schema__User;

    [key: string]: any;
}

/** `SearchResults` is a model that is used to return a list of users that match a search query.  It is used in the `/search` endpoint. */
export interface SearchResults {
    success: boolean;
    error?: string;
    response?: App__api__admin__schema__BaseUserResponse[];

    [key: string]: any;
}

/** `SearchUser` is a model that is used to search for users. It is used in the `/search` endpoint. */
export interface SearchUser {
    email?: string;
    username?: string;
    type: string;

    [key: string]: any;
}

export interface TokenDetail {
    accessToken: string;
    userClaim: UserClaim;

    [key: string]: any;
}

/** Base Response abstraction for standardized returns */
export interface TokenResponse {
    success: boolean;
    error?: string;
    response?: TokenDetail;

    [key: string]: any;
}

export interface UpdateGame {
    id: string;
    username: string;
    description: string;

    [key: string]: any;
}

export interface UpdateGameResponse {
    success: boolean;
    response?: App__api__game__schema__Game;

    [key: string]: any;
}

/** It's a model that represents a user that is being updated. */
export interface UpdateUser {
    id: string;
    password?: string;
    email?: string;
    username?: string;
    active?: boolean;

    [key: string]: any;
}

/** `UpdateUserCredit` is a class that is used to represent a request */
export interface UpdateUserCredit {
    ownerId: string;
    balance: number;

    [key: string]: any;
}

/** `UpdateUserCreditResponse` is a class that is used to represent a response */
export interface UpdateUserCreditResponse {
    success: boolean;
    error?: string;
    response?: App__api__credit__schema__UserCredit;

    [key: string]: any;
}

/** It's a model that represents a user that is being updated. */
export interface UpdateUserResponse {
    success: boolean;
    error?: string;
    response?: App__api__user__schema__User;

    [key: string]: any;
}

/** The UserClaim class is a model that represents a user's claim */
export interface UserClaim {
    id?: string;
    email?: string;
    admin?: boolean;
    agent?: boolean;
    expires?: string;

    [key: string]: any;
}

/** A class that is used to validate the data that is being passed to the `/login` route. */
export interface UserLogin {
    email: string;
    password: string;

    [key: string]: any;
}

export interface GeneratePassword {
    userId: string;

    [key: string]: any;
}

export interface ValidationError {
    loc: Loc[];
    msg: string;
    type: string;

    [key: string]: any;
}

/** It's a model that is used to return a list of users. */
export interface App__api__admin__schema__BaseUserResponse {
    id: string;
    email?: string;
    username?: string;
    createdAt?: Date;
    updatedAt?: Date;
    quota?: number;
    creditAccount?: App__api__credit__schema__UserCredit;
    active?: boolean;
    createdByAdmin?: AgentUser;
    createdByAgent?: Admin;

    [key: string]: any;
}

export interface App__api__admin__schema__GetAgent {
    id: string;

    [key: string]: any;
}

/** It's a model that is used to remove a user from the database. */
export interface App__api__admin__schema__RemoveUser {
    id: string;

    [key: string]: any;
}

/** It's a model that is used to return a list of users. */
export interface App__api__agent__schema__BaseUserResponse {
    id: string;
    email?: string;
    username?: string;
    active?: boolean;
    creditAccount?: App__api__user__schema__UserCredit;

    [key: string]: any;
}

/** `GetAgent` is a class that is used to represent a request */
export interface App__api__agent__schema__GetAgent {
    id: string;

    [key: string]: any;
}

/** It's a model that is used to remove a user from the database. */
export interface App__api__agent__schema__RemoveUser {
    id: string;

    [key: string]: any;
}

export interface App__api__agent__schema__User {
    id?: string;
    username?: string;
    email?: string;

    [key: string]: any;
}

export interface App__api__credit__schema__User {
    id?: string;
    email?: string;
    username?: string;

    [key: string]: any;
}

/** `UserCredit` is a class that is used to represent a user credit */
export interface App__api__credit__schema__UserCredit {
    id?: string;
    timestamp?: string;
    balance?: number;
    owner?: App__api__credit__schema__User;

    [key: string]: any;
}

export interface App__api__game__schema__Game {
    id: string;
    eGameName?: string;
    cGameName?: string;
    type?: number;
    jsonData?: any;
    createdAt?: Date;

    [key: string]: any;
}

/** `Game` is a class that is used to represent a game */
export interface App__api__history__schema__Game {
    id?: number;

    [key: string]: any;
}

/** `User` is a class that is used to represent a user */
export interface App__api__history__schema__User {
    id?: string;
    username?: string;
    email?: string;

    [key: string]: any;
}

export interface App__api__user__schema__User {
    id?: string;
    email?: string;
    balance?: App__api__user__schema__UserCredit;
    username?: string;
    createdAt?: string;

    [key: string]: any;
}

export interface App__api__user__schema__UserCredit {
    balance?: number;
    updatedAt?: Date;

    [key: string]: any;
}

export interface Owner {

    [key: string]: any;
}

export interface Response {

    [key: string]: any;
}

export interface Response2 {

    [key: string]: any;
}

export interface Loc {

    [key: string]: any;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}